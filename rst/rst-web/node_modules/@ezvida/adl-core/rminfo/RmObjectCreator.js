"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var ArchetypeSlot_1 = require("../am/ArchetypeSlot");
var TerminologyQuery_1 = require("../query/TerminologyQuery");
var Archetyped_1 = require("../rm/archetyped/Archetyped");
var Locatable_1 = require("../rm/archetyped/Locatable");
var CodePhrase_1 = require("../rm/CodePhrase");
var Composition_1 = require("../rm/composition/Composition");
var DvCodedText_1 = require("../rm/datavalues/DvCodedText");
var DvText_1 = require("../rm/datavalues/DvText");
var DvProportion_1 = require("../rm/datavalues/quantity/DvProportion");
var DvQuantified_1 = require("../rm/datavalues/quantity/DvQuantified");
var DvQuantity_1 = require("../rm/datavalues/quantity/DvQuantity");
var RmObject_1 = require("../rm/RmObject");
var ArchetypeId_1 = require("../rm/support/identification/ArchetypeId");
var ModelInfoLookup_1 = require("./ModelInfoLookup");
var TypeGuard_1 = require("./TypeGuard");
var RmObjectCreator = /** @class */ (function () {
    function RmObjectCreator(archetype) {
        this.archetype = archetype;
        this.classLookup = new ModelInfoLookup_1.ModelInfoLookup();
    }
    RmObjectCreator.prototype.create = function (constraint, root) {
        var clazz = this.classLookup.getClassToBeCreated(constraint.rmTypeName);
        if (clazz == null) {
            throw new Error("cannot construct RMObject because of unknown constraint name\n      " + constraint.rmTypeName + " full constraint " + constraint);
        }
        var result = createInstance(clazz);
        if (result instanceof Locatable_1.Locatable) {
            result.archetypeNodeId = constraint.nodeId;
            var term = void 0;
            // if (isOperationalTemplate(this.archetype)) {
            if (TypeGuard_1.isCArchetypeRoot(constraint)) {
                term = TerminologyQuery_1.TerminologyQuery.findTermDefinition(this.archetype, this.archetype.definition.nodeId, { overlayId: constraint.archetypeRef });
                var archetyped = new Archetyped_1.Archetyped();
                archetyped.archetypeId = new ArchetypeId_1.ArchetypeId(constraint.archetypeRef);
                result.archetypeDetails = archetyped;
                //At an archetype root point, the value of this attribute is always the stringified
                // form of the archetype_id found in the archetype_details object.
                result.archetypeNodeId = result.archetypeDetails.archetypeId.value;
            }
            else if (root) {
                term = TerminologyQuery_1.TerminologyQuery.findTermDefinition(this.archetype, constraint.nodeId, { overlayId: root.archetypeDetails.archetypeId.value });
            }
            else {
                term = TerminologyQuery_1.TerminologyQuery.findTermDefinition(this.archetype, constraint.nodeId);
            }
            result.name = new DvText_1.DvText({ value: term ? term.text : null });
            //form atribute
            result.name.description = term ? term.description : null;
        }
        //top-level information class
        if (result instanceof Composition_1.Composition) {
            var archetyped = new Archetyped_1.Archetyped();
            archetyped.archetypeId = new ArchetypeId_1.ArchetypeId(this.archetype.archetypeId);
            result.archetypeDetails = archetyped;
            //At an archetype root point, the value of this attribute is always the stringified
            // form of the archetype_id found in the archetype_details object.
            result.archetypeNodeId = result.archetypeDetails.archetypeId.value;
            var term = TerminologyQuery_1.TerminologyQuery.findTermDefinition(this.archetype, constraint.nodeId);
            result.name = new DvText_1.DvText({ value: term ? term.text : null });
        }
        var genericTypeName = parseGenericRmTypeName(constraint.rmTypeName);
        if (genericTypeName) {
            var genericClazz = this.classLookup.getClassToBeCreated(genericTypeName);
            if (genericClazz == null) {
                throw new Error("cannot construct RMObject because of unknown constraint name\n      " + genericTypeName + " full constraint " + constraint);
            }
            var dvInterval = result;
            dvInterval.lower = createInstance(genericClazz);
            dvInterval.upper = createInstance(genericClazz);
        }
        return result;
    };
    RmObjectCreator.prototype.setValues = function (object, rmAttributeName, values) {
        var attributeInfo = this.classLookup.getAttributeInfo(object, rmAttributeName);
        if (attributeInfo == null) {
            throw new Error("Attribute '" + rmAttributeName + "' not known for object '" + object.constructor.name + "'");
        }
        var value = values[0];
        if (attributeInfo.elements) {
            value = values;
        }
        object[attributeInfo.name] = _.clone(value);
    };
    RmObjectCreator.prototype.setConstraint = function (object, rmAttributeName, values, root) {
        if (values instanceof ArchetypeSlot_1.ArchetypeSlot || values.rmTypeName === 'ArchetypeSlot') {
            return;
        }
        //ignore DV_QUANTIFIED.property https://openehr.atlassian.net/browse/SPEC-95
        if (object instanceof DvQuantified_1.DvQuantified && rmAttributeName === 'property') {
            return;
        }
        if (object instanceof DvProportion_1.DvProportion && rmAttributeName === 'is_integral') {
            return;
        }
        var attributeInfo = this.classLookup.getAttributeInfo(object, rmAttributeName);
        if (attributeInfo == null) {
            console.warn("Attribute '" + rmAttributeName + "' not known for object '" + object.constructor.name + "'");
            return;
            //throw new Error(`Attribute '${rmAttributeName}' not known for object '${object.constructor.name}'`);
        }
        if (object instanceof DvCodedText_1.DvCodedText) {
            var term = values;
            object.definingCode = new CodePhrase_1.CodePhrase({ codeString: term.constraint });
            object.value = term.assumedValue;
            var codes = TerminologyQuery_1.TerminologyQuery.findValueSets(this.archetype, term.constraint, root ? root.archetypeNodeId : undefined);
            var codeList = [];
            var termBindingItem = TerminologyQuery_1.TerminologyQuery.findTermBinds(this.archetype, term.constraint, root ? root.archetypeNodeId : undefined);
            var externalTerm = !codes && !!termBindingItem;
            if (!externalTerm) {
                try {
                    for (var codes_1 = tslib_1.__values(codes), codes_1_1 = codes_1.next(); !codes_1_1.done; codes_1_1 = codes_1.next()) {
                        var code = codes_1_1.value;
                        codeList.push({
                            code: code,
                            text: TerminologyQuery_1.TerminologyQuery.findTermDefinitionByValueSet(this.archetype, code, root ? root.archetypeNodeId : undefined).text
                        });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (codes_1_1 && !codes_1_1.done && (_a = codes_1.return)) _a.call(codes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            Object.assign(object, { constraint: { codeList: codeList, externalTerm: externalTerm, termBindingItem: termBindingItem } });
        }
        else if (object instanceof DvText_1.DvText) {
            var cstring = values;
            object.value = cstring.assumedValue;
        }
        else if (object instanceof DvQuantity_1.DvQuantity) {
            object.constraint = object.constraint || {};
            var constraint = {};
            constraint[attributeInfo.name] = values.constraint;
            _.mergeWith(object.constraint, constraint, arrayCustomizer);
            if (values.assumedValue) {
                object[attributeInfo.name] = values.assumedValue;
            }
        }
        var e_1, _a;
    };
    RmObjectCreator.prototype.isMultipleValued = function (result, rmAttributeName) {
        return this.classLookup.isMultipleValued(result, rmAttributeName);
    };
    RmObjectCreator.prototype.addElementToListOrSetSingleValues = function (object, attribute, element) {
        var attributeInfo = this.classLookup.getAttributeInfo(object, attribute);
        if (!attributeInfo.elements) {
            this.setValues(object, attribute, [element]);
        }
        else {
            this.addElementToList(object, attributeInfo, element);
        }
    };
    RmObjectCreator.prototype.addElementToList = function (object, attributeInfo, element) {
        try {
            object[attributeInfo.name] = object[attributeInfo.name] || [];
            if (object instanceof Locatable_1.Locatable && element instanceof Locatable_1.Locatable) {
                // noinspection TsLint
                var index = _.findLastIndex(object[attributeInfo.name], function (locatable) { return locatable.archetypeNodeId === element.archetypeNodeId; });
                if (index !== -1) {
                    object[attributeInfo.name].splice(index + 1, 0, element);
                    element.parent = object;
                    this.traverseWithPath(object);
                    return;
                }
            }
            object[attributeInfo.name].push(element);
            this.traverseWithPath(object);
        }
        catch (e) {
            throw new Error("trying to add an element to an object with type " + attributeInfo.type);
        }
    };
    RmObjectCreator.prototype.traverseWithPath = function (object) {
        try {
            for (var _a = tslib_1.__values(Object.keys(object)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var propertyKey = _b.value;
                var member = object[propertyKey];
                var attributeInfo = this.classLookup.getAttributeInfo(object, propertyKey);
                if (attributeInfo && member) {
                    if (attributeInfo.elements && _.isArray(member)) {
                        try {
                            for (var _c = tslib_1.__values(member.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var _e = tslib_1.__read(_d.value, 2), index = _e[0], el = _e[1];
                                if (el instanceof RmObject_1.RmObject && el.aPath) {
                                    el.aPath = object.aPath + "/" + _.snakeCase(attributeInfo.name) + "[" + index + "]";
                                    this.traverseWithPath(el);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    else if (member instanceof RmObject_1.RmObject && member.aPath) {
                        member.aPath = object.aPath + "/" + _.snakeCase(attributeInfo.name);
                        this.traverseWithPath(member);
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_g = _a.return)) _g.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var e_3, _g, e_2, _f;
    };
    return RmObjectCreator;
}());
exports.RmObjectCreator = RmObjectCreator;
function createInstance(c) {
    return new c();
}
function arrayCustomizer(objValue, srcValue) {
    if (_.isArray(objValue)) {
        return objValue.concat(srcValue);
    }
    return undefined;
}
function parseGenericRmTypeName(rmTypeName) {
    var ltPos = rmTypeName.indexOf('<');
    var gtPos = rmTypeName.lastIndexOf('>');
    return rmTypeName.substring(ltPos + 1, gtPos);
}
//# sourceMappingURL=RmObjectCreator.js.map