"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var misc_1 = require("antlr4ts/misc");
var assert_1 = require("assert");
var CBoolean_1 = require("../../am/CBoolean");
var CNumber_1 = require("../../am/CNumber");
var CString_1 = require("../../am/CString");
var CTemporal_1 = require("../../am/CTemporal");
var CTerminologyCode_1 = require("../../am/CTerminologyCode");
var Interval_1 = require("../../rm/Interval");
var RmObjectFactory_1 = require("../../rm/RmObjectFactory");
var RmTypes_1 = require("../../rm/RmTypes");
var AdlTreeParserUtils_1 = require("./AdlTreeParserUtils");
function parsePrimitiveValue(ctx) {
    if (ctx.stringConstraint() != null) {
        return parseString(ctx.stringConstraint(), ctx.STRING());
    }
    if (ctx.booleanList() != null) {
        return parseBoolean(ctx.booleanList(), ctx.bool());
    }
    if (ctx.numberConstraint() != null) {
        return parseCNumber(ctx.numberConstraint(), ctx.number());
    }
    if (ctx.dateConstraint() != null) {
        return parseDate(ctx.dateConstraint(), ctx.ISO_DATE());
    }
    if (ctx.timeConstraint() != null) {
        return parseTime(ctx.timeConstraint(), ctx.ISO_TIME());
    }
    if (ctx.dateTimeConstraint() != null) {
        return parseDateTime(ctx.dateTimeConstraint(), ctx.ISO_DATE_TIME());
    }
    if (ctx.durationConstraint() != null) {
        return parseDuration(ctx.durationConstraint(), ctx.DURATION());
    }
    if (ctx.terminologyCodeConstraint() != null) {
        return parseTerminologyCode(ctx.terminologyCodeConstraint());
    }
    throw new assert_1.AssertionError();
}
exports.parsePrimitiveValue = parsePrimitiveValue;
function parseNumber(ctx) {
    if (ctx == null) {
        return null;
    }
    if (ctx.text.match(/^[+-]?\d+\.\d+$/)) {
        return Number.parseFloat(ctx.text);
    }
    return Number.parseInt(ctx.text);
}
exports.parseNumber = parseNumber;
var isFloat = function (num) { return num % 1 !== 0; };
function parseCNumber(ctx, assumedValue) {
    var numbers = [];
    var intervals = [];
    if (ctx.numberList() != null) {
        numbers = ctx.numberList().number().map(parseNumber);
    }
    if (ctx.numberIntervalConstraint() != null) {
        intervals = ctx.numberIntervalConstraint().map(parseNumberInterval);
    }
    var result = new CNumber_1.CNumber();
    result.rmTypeName = (!!numbers && numbers.find(isFloat))
        || (!!intervals && intervals.find(function (interval) { return isFloat(interval.upper) || isFloat(interval.lower); }))
        ? RmTypes_1.RmTypes.REAL : RmTypes_1.RmTypes.INTEGER;
    if (assumedValue != null) {
        result.assumedValue = parseNumber(assumedValue);
    }
    result.constraint = tslib_1.__spread(intervals, numbers.map(function (num) { return RmObjectFactory_1.RmObjectFactory.createInterval(num, num); }));
    return result;
}
exports.parseCNumber = parseCNumber;
function parseNumberInterval(ctx) {
    var lower = parseNumber(ctx._lower);
    var upper = parseNumber(ctx._upper);
    var val = parseNumber(ctx._val);
    return parseInterval(lower, upper, val, ctx._gt, ctx._gte, ctx._lt, ctx._lte);
}
exports.parseNumberInterval = parseNumberInterval;
function parseStringInterval(ctx) {
    var lower = AdlTreeParserUtils_1.collectText(ctx._lower);
    var upper = AdlTreeParserUtils_1.collectText(ctx._upper);
    var val = AdlTreeParserUtils_1.collectText(ctx._val);
    return parseInterval(lower, upper, val, ctx._gt, ctx._gte, ctx._lt, ctx._lte);
}
function parseInterval(lower, upper, val, gt, gte, lt, lte) {
    var result = new Interval_1.Interval();
    // map single val interval into upper/lower
    if (val != null) {
        if (gt == null && lt == null) {
            result.lower = val;
            result.upper = val;
        }
        else if (gt != null) {
            result.lower = val;
            result.upper = null;
        }
        else {
            result.lower = null;
            result.upper = val;
        }
    }
    else {
        result.lower = lower;
        result.upper = upper;
    }
    result.lowerUnbounded = result.lower == null;
    result.lowerIncluded = result.lower != null && (gt == null || gte != null);
    result.upperUnbounded = result.upper == null;
    result.upperIncluded = result.upper != null && (lt == null || lte != null);
    return result;
}
exports.parseInterval = parseInterval;
function parseString(ctx, assumedValue) {
    var result = new CString_1.CString();
    result.rmTypeName = RmTypes_1.RmTypes.STRING;
    if (ctx.stringList() != null) {
        result.constraint = AdlTreeParserUtils_1.collectStringList(ctx.stringList());
    }
    if (ctx.regularExpression() != null) {
        result.pattern = collectRegularExpression(ctx.regularExpression());
    }
    result.assumedValue = AdlTreeParserUtils_1.collectText(assumedValue);
    return result;
}
function collectRegularExpression(tRegularExpression) {
    var start = tRegularExpression.start.startIndex;
    var stop = tRegularExpression.stop.stopIndex;
    return tRegularExpression.start.inputStream.getText(new misc_1.Interval(start + 1, stop - 1));
}
function parseBoolean(ctx, assumedValue) {
    var result = new CBoolean_1.CBoolean();
    result.rmTypeName = RmTypes_1.RmTypes.BOOLEAN;
    if (ctx.bool() != null) {
        result.constraint = ctx.bool().map(function (bool) { return bool.TRUE != null; });
    }
    if (assumedValue != null) {
        result.assumedValue = assumedValue.TRUE() != null;
    }
    return result;
}
function parseDate(ctx, assumedValue) {
    var result = new CTemporal_1.CTemporal();
    result.rmTypeName = RmTypes_1.RmTypes.DATE;
    result.patternConstraint = AdlTreeParserUtils_1.collectText(ctx.DATE_PATTERN());
    result.constraint = [];
    if (ctx.ISO_DATE() != null) {
        result.constraint.push(RmObjectFactory_1.RmObjectFactory.createInterval(ctx.ISO_DATE().text, ctx.ISO_DATE().text));
    }
    if (ctx.dateIntervalConstraint() != null) {
        (_a = result.constraint).push.apply(_a, tslib_1.__spread(ctx.dateIntervalConstraint().map(parseStringInterval)));
    }
    result.assumedValue = AdlTreeParserUtils_1.collectText(assumedValue);
    return result;
    var _a;
}
function parseTime(ctx, assumedValue) {
    var result = new CTemporal_1.CTemporal();
    result.rmTypeName = RmTypes_1.RmTypes.TIME;
    result.patternConstraint = AdlTreeParserUtils_1.collectText(ctx.TIME_PATTERN());
    result.constraint = [];
    if (ctx.ISO_TIME() != null) {
        result.constraint.push(RmObjectFactory_1.RmObjectFactory.createInterval(ctx.ISO_TIME().text, ctx.ISO_TIME().text));
    }
    if (ctx.timeIntervalConstraint() != null) {
        (_a = result.constraint).push.apply(_a, tslib_1.__spread(ctx.timeIntervalConstraint().map(parseStringInterval)));
    }
    result.assumedValue = AdlTreeParserUtils_1.collectText(assumedValue);
    return result;
    var _a;
}
function parseDateTime(ctx, assumedValue) {
    var result = new CTemporal_1.CTemporal();
    result.rmTypeName = RmTypes_1.RmTypes.DATE_TIME;
    result.patternConstraint = AdlTreeParserUtils_1.collectText(ctx.DATE_TIME_PATTERN());
    result.constraint = [];
    if (ctx.ISO_DATE_TIME() != null) {
        result.constraint.push(RmObjectFactory_1.RmObjectFactory.createInterval(ctx.ISO_DATE_TIME().text, ctx.ISO_DATE_TIME().text));
    }
    if (ctx.dateTimeIntervalConstraint() != null) {
        (_a = result.constraint).push.apply(_a, tslib_1.__spread(ctx.dateTimeIntervalConstraint().map(parseStringInterval)));
    }
    result.assumedValue = AdlTreeParserUtils_1.collectText(assumedValue);
    return result;
    var _a;
}
function parseDuration(ctx, assumedValue) {
    var result = new CTemporal_1.CTemporal();
    result.rmTypeName = RmTypes_1.RmTypes.DURATION;
    if (ctx._pattern != null) {
        result.patternConstraint = ctx._pattern.text;
    }
    result.constraint = [];
    if (ctx._singleInterval != null) {
        result.constraint.push(RmObjectFactory_1.RmObjectFactory.createInterval(ctx._singleInterval.text, ctx._singleInterval.text));
    }
    else if (ctx.durationIntervalConstraint() != null) {
        result.constraint.push(parseStringInterval(ctx.durationIntervalConstraint()));
    }
    result.assumedValue = AdlTreeParserUtils_1.collectText(assumedValue);
    return result;
}
function parseTerminologyCode(ctx) {
    var result = new CTerminologyCode_1.CTerminologyCode();
    result.constraint = ctx._constraint.text;
    if (ctx._assumedValue != null) {
        result.assumedValue = ctx._assumedValue.text;
    }
    return result;
}
//# sourceMappingURL=AdlTreePrimitiveConstraintsParser.js.map