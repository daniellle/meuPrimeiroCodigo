"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Segment = /** @class */ (function () {
    function Segment() {
    }
    return Segment;
}());
exports.Segment = Segment;
var RmPath = /** @class */ (function () {
    function RmPath(parent, attribute, nodeId) {
        var _this = this;
        this.toString = function () {
            return _this.buildToString('');
        };
        if (attribute == null) {
            throw new Error('attribute null');
        }
        this.parent = parent;
        this.attribute = attribute;
        this.nodeId = nodeId;
    }
    RmPath.VALUE_OF = function (str) {
        if (str.startsWith('/')) {
            str = str.substring(1);
        }
        var path = RmPath.ROOT;
        var segments = RmPath.PARSE_SEGMENTS(str);
        try {
            for (var segments_1 = tslib_1.__values(segments), segments_1_1 = segments_1.next(); !segments_1_1.done; segments_1_1 = segments_1.next()) {
                var segment = segments_1_1.value;
                path = new RmPath(path, segment.attribute, segment.nodeId);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (segments_1_1 && !segments_1_1.done && (_a = segments_1.return)) _a.call(segments_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return path;
        var e_1, _a;
    };
    RmPath.PARSE_SEGMENTS = function (origPathStr) {
        var pathStr = origPathStr;
        if (!pathStr.startsWith('/')) {
            pathStr = pathStr + "/";
        }
        var result = [];
        try {
            for (var _a = tslib_1.__values(pathStr.split('/').filter(function (x) { return x; })), _b = _a.next(); !_b.done; _b = _a.next()) {
                var segmentStr = _b.value;
                var match = RmPath.SEGMENT_PATTERN.exec(segmentStr);
                if (match == null) {
                    throw new Error("Bad aql path: " + segmentStr);
                }
                var segment = new Segment();
                segment.attribute = match[1];
                segment.nodeId = match[3];
                result.push(segment);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
        var e_2, _c;
    };
    RmPath.prototype.segments = function () {
        var result = [];
        var path = this;
        while (path != null && path.parent != null) {
            result.push(path);
            path = path.parent;
        }
        result.reverse();
        return result;
    };
    RmPath.prototype.resolve = function (attribute, nodeId) {
        return new RmPath(this, attribute, nodeId);
    };
    RmPath.prototype.constrain = function (nodeId) {
        if (!(this.nodeId == null || nodeId == null)) {
            throw new Error('Path already constrained');
        }
        if (this.nodeId === nodeId) {
            return this;
        }
        return new RmPath(this.parent, this.attribute, nodeId);
    };
    RmPath.prototype.buildToString = function (builder) {
        if (this.parent != null) {
            builder = this.parent.buildToString(builder);
            builder = builder + "/";
        }
        builder = "" + builder + this.attribute;
        if (this.nodeId != null) {
            builder = builder + "[" + this.nodeId + "]";
        }
        return builder;
    };
    RmPath.ROOT = new RmPath(null, '', null);
    RmPath.SEGMENT_PATTERN = /([a-zA-Z0-9_]*)(\[([^\]]+)\])?/;
    return RmPath;
}());
exports.RmPath = RmPath;
//# sourceMappingURL=RmPath.js.map