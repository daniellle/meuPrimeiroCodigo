import { Archetype } from '../am/Archetype';
export declare class ArchetypeFlattener {
    /**
     * Flattens a specialized source archetype
     *
     * @param flatParent   Parent archetype. Must already be flattened. Can be null if differentialArchetype is not specialized
     * @param differential Differential (source) archetype
     * @return Specialized archetype in flattened form
     */
    flatten(flatParent: Archetype, differential: Archetype): Archetype;
    /**
     * Merges a specialized archetype with its parent. Merge will be done in-place on the specialized parameter.
     *
     * @param flatParent  Flat parent archetype
     * @param specialized Specialized archetype
     */
    merge(flatParent: Archetype, specialized: Archetype): void;
    private flattenCComplexObject(path, flatParent, specialized);
    private flattenCComplexObjectTuples(flatParent, specialized);
    private flattenCComplexObjectAttributes(path, flatParent, specialized);
    private addCComplexObjectSpecializedAttributes(path, flatParent, specialized);
    private addParentAttributesThatWereNotSpecialized(flatParent, specialized, originalSpecializedAttributes);
    private flattenCArchetypeSlot(parent, specialized);
    private findAttribute;
    private expandSpecializedAttribute(sourceObject, specializedAttribute);
    private expandAttribute(sourceObject, intermediateSegments, targetAttribute);
    private expandAttributeNodes(sourceObject);
    private mergeAttribute(parent, result);
    private flattenCAttribute(path, parent, specialized);
    private atCodeMatchesOrSpecializes(atCode, sameOrParentCode);
    private findParentConstraintOfSpecializedNodeIndex(parentConses, nodeId);
    private findParentConstraintWithRmType(parent, rmType);
    private findParentConstraintOfSpecializedNode(parent, nodeId);
    private unspecializeNodeId(nodeId);
    private addSpecializedChildren(conses, children);
    private flattenCObject(path, _container, parent, specialized);
}
