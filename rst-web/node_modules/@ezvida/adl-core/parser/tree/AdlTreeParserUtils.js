"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var antlr4ts_1 = require("antlr4ts");
var misc_1 = require("antlr4ts/misc");
var tree_1 = require("antlr4ts/tree");
var querystring = require("querystring");
var AdlLexer_1 = require("../../grammar/AdlLexer");
var AdlParser_1 = require("../../grammar/AdlParser");
var CodePhrase_1 = require("../../rm/CodePhrase");
var AdlTreeParserException_1 = require("../AdlTreeParserException");
function collectText(ctx) {
    if (ctx == null) {
        return null;
    }
    if (ctx instanceof tree_1.TerminalNode) {
        if (ctx._symbol.type === AdlLexer_1.AdlLexer.STRING) {
            return unescapeString(ctx.text);
        }
    }
    else if (isToken(ctx)) {
        if (ctx.type === AdlLexer_1.AdlLexer.STRING) {
            return unescapeString(ctx.text);
        }
    }
    return ctx.text;
}
exports.collectText = collectText;
function isToken(obj) {
    return obj.type !== undefined;
}
function tokenOf(tree) {
    if (tree instanceof tree_1.TerminalNode) {
        return tree._symbol;
    }
    else if (tree instanceof antlr4ts_1.ParserRuleContext) {
        return tree._start;
    }
    return null;
}
exports.tokenOf = tokenOf;
function collectNonNullText(ctx) {
    var result = collectText(ctx);
    if (result == null) {
        throw new AdlTreeParserException_1.AdlTreeParserException(tokenOf(ctx), 'Text must not be null');
    }
    return result;
}
exports.collectNonNullText = collectNonNullText;
function collectString(tStringList) {
    if (tStringList == null) {
        return null;
    }
    if (tStringList instanceof AdlParser_1.OdinValueContext) {
        return collectString(tStringList.openStringList());
    }
    return unescapeString(collectText(tStringList));
}
exports.collectString = collectString;
function unescapeString(str) {
    if (str.startsWith('"') && str.endsWith('"')) {
        str = str.substring(1, str.length - 1);
    }
    return querystring.unescape(str);
}
exports.unescapeString = unescapeString;
function getAdlPropertyOrNull(adlContext, name) {
    var properties = adlContext.odinObjectProperty();
    var result = properties.find(function (propertyContext) {
        var identifier = collectNonNullText(propertyContext.identifier());
        return identifier === name;
    });
    return !result ? null : result.odinValue();
}
exports.getAdlPropertyOrNull = getAdlPropertyOrNull;
function collectStringList(tStringList) {
    if (tStringList == null) {
        return [];
    }
    var contexts = tStringList.STRING();
    return contexts.map(function (context) {
        return unescapeString(collectText(context));
    });
}
exports.collectStringList = collectStringList;
function parseAtCode(ctx) {
    if (ctx == null) {
        return null;
    }
    return ctx.AT_CODE_VALUE().text;
}
exports.parseAtCode = parseAtCode;
function collectTextWithSpaces(ctx) {
    var start = ctx.start.startIndex;
    var stop = ctx.stop.stopIndex;
    return ctx.start.inputStream.getText(new misc_1.Interval(start, stop));
}
exports.collectTextWithSpaces = collectTextWithSpaces;
function parseCodePhrase(ctx) {
    return new CodePhrase_1.CodePhrase({ terminologyId: collectText(ctx._tid), codeString: collectText(ctx._code) });
}
exports.parseCodePhrase = parseCodePhrase;
function parseCodePhraseListSingleItem(ctx) {
    var phrases = ctx.odinCodePhraseValue();
    if (phrases.length !== 1) {
        throw new AdlTreeParserException_1.AdlTreeParserException(tokenOf(ctx), 'Expected exactly one code phrase in list');
    }
    return parseCodePhrase(phrases[0]);
}
exports.parseCodePhraseListSingleItem = parseCodePhraseListSingleItem;
function parseInteger(tNumber) {
    var num = Number.parseInt(collectNonNullText(tNumber));
    if (isNaN(num)) {
        throw new AdlTreeParserException_1.AdlTreeParserException(tokenOf(tNumber), "Invalid integer: " + collectNonNullText(tNumber));
    }
    return num;
}
exports.parseInteger = parseInteger;
//# sourceMappingURL=AdlTreeParserUtils.js.map