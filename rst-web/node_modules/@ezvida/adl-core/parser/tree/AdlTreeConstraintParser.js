"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("assert");
var ArchetypeInternalRef_1 = require("../../am/ArchetypeInternalRef");
var ArchetypeSlot_1 = require("../../am/ArchetypeSlot");
var Assertion_1 = require("../../am/Assertion");
var CArchetypeRoot_1 = require("../../am/CArchetypeRoot");
var Cardinality_1 = require("../../am/Cardinality");
var CAttribute_1 = require("../../am/CAttribute");
var CAttributeTuple_1 = require("../../am/CAttributeTuple");
var CComplexObject_1 = require("../../am/CComplexObject");
var CDvOrdinal_1 = require("../../am/CDvOrdinal");
var CDvQuantity_1 = require("../../am/CDvQuantity");
var CObjectTuple_1 = require("../../am/CObjectTuple");
var CQuantityItem_1 = require("../../am/CQuantityItem");
var OperatorKind_1 = require("../../am/OperatorKind");
var SiblingOrder_1 = require("../../am/SiblingOrder");
var AdlParser_1 = require("../../grammar/AdlParser");
var DvCodedText_1 = require("../../rm/datavalues/DvCodedText");
var DvOrdinal_1 = require("../../rm/datavalues/quantity/DvOrdinal");
var DvQuantity_1 = require("../../rm/datavalues/quantity/DvQuantity");
var RmObjectFactory_1 = require("../../rm/RmObjectFactory");
var RmTypes_1 = require("../../rm/RmTypes");
var AdlTreeParserException_1 = require("../AdlTreeParserException");
var AdlTreeParserUtils_1 = require("./AdlTreeParserUtils");
var AdlTreePrimitiveConstraintsParser_1 = require("./AdlTreePrimitiveConstraintsParser");
var OdinObject_1 = require("./OdinObject");
var AdlTreeConstraintParser = /** @class */ (function () {
    function AdlTreeConstraintParser(archetype) {
        this.archetype = archetype;
        this.archetype.paths = [];
    }
    AdlTreeConstraintParser.prototype.parseComplexObject = function (ctx, path) {
        if (path === void 0) { path = '/'; }
        var result = new CComplexObject_1.CComplexObject();
        result.rmTypeName = AdlTreeParserUtils_1.collectText(ctx.typeIdentifierWithGenerics());
        result.nodeId = AdlTreeParserUtils_1.parseAtCode(ctx.atCode());
        result.occurrences = this.parseOccurrences(ctx.occurrences());
        result.rmType = CComplexObject_1.CComplexObject.name;
        result.aPath = path !== '/' ? path + "[" + result.nodeId + "]" : '';
        /*this.archetype.paths.push({
          aPath: result.aPath === '' ? '/' : result.aPath,
          type: result.rmTypeName,
          value: undefined
        });*/
        this.parseAttributeList(result, ctx.attributeListMatcher());
        return result;
    };
    AdlTreeConstraintParser.prototype.parseOccurrences = function (ctx) {
        if (ctx == null) {
            return null;
        }
        if (ctx instanceof AdlParser_1.OccurrencesContext) {
            return this.parseOccurrences(ctx.occurrenceRange());
        }
        if (ctx._val != null) {
            var val = Number.parseInt(ctx._val.text);
            return RmObjectFactory_1.RmObjectFactory.createMultiplicityInterval(val, val);
        }
        var lower = ctx._lower != null ? Number.parseInt(ctx._lower.text) : 0;
        var upper = ctx._upper != null ? Number.parseInt(ctx._upper.text) : null;
        return RmObjectFactory_1.RmObjectFactory.createMultiplicityInterval(lower, upper);
    };
    AdlTreeConstraintParser.prototype.parseAttributeList = function (target, ctx) {
        var _this = this;
        if (ctx == null || ctx.attributeConstraint() == null) {
            return;
        }
        target.attributes = [];
        target.attributeTuples = [];
        ctx.attributeConstraint().forEach(function (cAttribute) {
            //atribute tuple ou atribute
            if (cAttribute.attributeIdentifier() != null) {
                target.attributes.push(_this.parseAttribute(cAttribute, target.aPath));
            }
            else if (cAttribute.tupleAttributeIdentifier() != null) {
                target.attributeTuples.push(_this.parseAttributeTuple(cAttribute));
            }
            else {
                throw new assert_1.AssertionError();
            }
        });
    };
    AdlTreeConstraintParser.prototype.parseAttribute = function (ctx, path) {
        var result = new CAttribute_1.CAttribute();
        if (ctx.existence() != null) {
            result.existence = this.parseOccurrences(ctx.existence().occurrenceRange());
        }
        result.cardinality = this.parseCardinality(ctx.cardinality());
        if (ctx.attributeIdentifier() == null) {
            throw new assert_1.AssertionError();
        }
        var rmPathCtx = ctx.attributeIdentifier().rmPath();
        result.rmAttributeName = AdlTreeParserUtils_1.collectNonNullText(rmPathCtx.pathSegment()[rmPathCtx.pathSegment().length - 1]);
        if (ctx.attributeIdentifier().rmPath()._start.text === '/') {
            result.differentialPath = AdlTreeParserUtils_1.collectNonNullText(rmPathCtx);
        }
        path = path + "/" + result.rmAttributeName;
        result.children = this.parseMultiValue(ctx.multiValueConstraint(), path);
        return result;
    };
    AdlTreeConstraintParser.prototype.parseCardinality = function (context) {
        if (context == null) {
            return null;
        }
        var result = new Cardinality_1.Cardinality();
        result.interval = this.parseOccurrences(context.occurrenceRange());
        result.isOrdered = !!context.ORDERED();
        result.isUnique = !!context.UNIQUE();
        return result;
    };
    AdlTreeConstraintParser.prototype.parseMultiValue = function (ctx, path) {
        var _this = this;
        if (ctx == null) {
            return [];
        }
        return ctx.valueConstraint().map(function (valueConstraintContext) {
            return _this.parseValueConstraint(valueConstraintContext, path);
        });
    };
    AdlTreeConstraintParser.prototype.parseValueConstraint = function (ctx, path) {
        if (ctx.typeConstraint() != null) {
            return this.parseTypeDefinition(ctx.typeConstraint(), path);
        }
        if (ctx.primitiveValueConstraint() != null) {
            return AdlTreePrimitiveConstraintsParser_1.parsePrimitiveValue(ctx.primitiveValueConstraint());
        }
        if (ctx.ordinalConstraint() != null) {
            return this.parseCDvOrdinalConstraint(ctx.ordinalConstraint());
        }
        throw new Error('NotImplementedException: codePhraseConstraint');
    };
    AdlTreeConstraintParser.prototype.parseTypeDefinition = function (ctx, path) {
        var result;
        if (ctx.complexObjectConstraint() != null) {
            result = this.parseComplexObject(ctx.complexObjectConstraint(), path);
        }
        else if (ctx.USE_NODE() != null) {
            result = this.parseArchetypeInternalRef(ctx, path);
        }
        else if (ctx.archetypeSlotConstraint() != null) {
            result = this.parseArchetypeSlot(ctx.archetypeSlotConstraint(), path);
            /* } else if (ctx.odinValue() != null) {
              result = parseAdlValueConstraint(ctx.odinValue()); */
        }
        else if (ctx.archetypeReferenceConstraint() != null) {
            result = this.parseArchetypeReference(ctx.archetypeReferenceConstraint(), path);
        }
        else {
            throw new Error('NotImplementedException');
        }
        result.siblingOrder = this.parseSiblingOrder(ctx.orderConstraint());
        return result;
    };
    /**
     * Internal References (Proxy Constraint Objects)
     * eg. use_node TYPE[idN] archetype_path
     */
    AdlTreeConstraintParser.prototype.parseArchetypeInternalRef = function (ctx, path) {
        var result = new ArchetypeInternalRef_1.ArchetypeInternalRef();
        result.rmTypeName = AdlTreeParserUtils_1.collectText(ctx.typeIdentifierWithGenerics());
        result.nodeId = AdlTreeParserUtils_1.parseAtCode(ctx.atCode());
        result.occurrences = this.parseOccurrences(ctx.occurrences());
        result.targetPath = AdlTreeParserUtils_1.collectText(ctx.rmPath());
        result.rmType = ArchetypeInternalRef_1.ArchetypeInternalRef.name;
        result.aPath = result.nodeId != null ? path + "[" + result.nodeId + "]" : "" + path;
        //this.archetype.paths.push({aPath: result.aPath, type: result.rmTypeName, value: undefined});
        return result;
    };
    AdlTreeConstraintParser.prototype.parseSiblingOrder = function (ctx) {
        if (ctx == null) {
            return null;
        }
        var result = new SiblingOrder_1.SiblingOrder();
        result.isBefore = ctx.BEFORE() != null;
        result.siblingNodeId = AdlTreeParserUtils_1.parseAtCode(ctx.atCode());
        return result;
    };
    /**
     * External References Slot. ie. An archetype slot defines a constrained
     * compositional chaining point in an archetype at which other archetypes
     * can be inserted, if they are in the set defined by the slot constraint.
     */
    AdlTreeConstraintParser.prototype.parseArchetypeSlot = function (ctx, path) {
        var result = new ArchetypeSlot_1.ArchetypeSlot();
        result.rmTypeName = AdlTreeParserUtils_1.collectText(ctx.typeIdentifierWithGenerics());
        result.rmType = ArchetypeSlot_1.ArchetypeSlot.name;
        result.nodeId = AdlTreeParserUtils_1.parseAtCode(ctx.atCode());
        result.occurrences = this.parseOccurrences(ctx.occurrences());
        if (ctx.archetypeSlotValueConstraint() != null) {
            var cValue = ctx.archetypeSlotValueConstraint();
            result.includes = this.parseAssertions(cValue._include);
            result.excludes = this.parseAssertions(cValue._exclude);
        }
        result.isClosed = ctx.CLOSED() != null;
        result.aPath = path + "[" + result.nodeId + "]";
        //this.archetype.paths.push({aPath: result.aPath, type: result.rmTypeName, value: undefined});
        return result;
    };
    AdlTreeConstraintParser.prototype.parseAssertions = function (cAssertions) {
        if (cAssertions == null) {
            return null;
        }
        return cAssertions.map(this.parseAssertion);
    };
    AdlTreeConstraintParser.prototype.parseAssertion = function (cAssertion) {
        var result = new Assertion_1.Assertion();
        result.stringExpression = AdlTreeParserUtils_1.collectTextWithSpaces(cAssertion);
        var cPrimitiveObject = AdlTreePrimitiveConstraintsParser_1.parsePrimitiveValue(cAssertion.primitiveValueConstraint());
        result.expression = {
            type: RmTypes_1.RmTypes.ReferenceType.CONSTRAINT,
            operator: OperatorKind_1.OperatorKind.MATCHES,
            precedenceOverridden: false,
            leftOperand: {
                type: RmTypes_1.RmTypes.STRING,
                referenceType: RmTypes_1.RmTypes.ReferenceType.ATTRIBUTE,
                item: AdlTreeParserUtils_1.collectText(cAssertion.rmPath())
            },
            rightOperand: {
                type: cPrimitiveObject.rmTypeName,
                referenceType: RmTypes_1.RmTypes.ReferenceType.CONSTRAINT,
                item: cPrimitiveObject
            }
        };
        return result;
    };
    AdlTreeConstraintParser.prototype.parseAttributeTuple = function (ctx) {
        var result = new CAttributeTuple_1.CAttributeTuple();
        result.members = ctx.tupleAttributeIdentifier().attributeIdentifier().map(function (cAttribute) {
            return { rmAttributeName: AdlTreeParserUtils_1.collectText(cAttribute.rmPath()), children: [] };
        });
        result.children = ctx.tupleChildConstraints().tupleChildConstraint().map(function (cTuple) {
            var tuple = new CObjectTuple_1.CObjectTuple();
            tuple.members = cTuple.primitiveValueConstraint().map(function (cConstraint) {
                return AdlTreePrimitiveConstraintsParser_1.parsePrimitiveValue(cConstraint);
            });
            return tuple;
        });
        return result;
    };
    /**
     * @Deprecated ADL 1.4
     * @param {OdinValueContext} ctx
     * @returns {CObject}
     */
    AdlTreeConstraintParser.prototype.parseAdlValueConstraint = function (ctx) {
        var amType = AdlTreeParserUtils_1.collectText(ctx.typeIdentifier());
        if ('C_DV_QUANTITY' === amType || amType == null) {
            return this.parseCDvQuantityConstraint(ctx);
        }
        else if ('C_DV_ORDINAL' === amType) {
            var result = new CDvOrdinal_1.CDvOrdinal();
            result.rmTypeName = 'DV_ORDINAL';
            return result;
        }
        else {
            throw new AdlTreeParserException_1.AdlTreeParserException(ctx._start, "Bad adl value am type: " + amType);
        }
    };
    AdlTreeConstraintParser.prototype.parseCDvQuantityConstraint = function (ctx) {
        var _this = this;
        var result = new CDvQuantity_1.CDvQuantity();
        result.rmTypeName = 'DV_QUANTITY';
        if (ctx == null) {
            return result;
        }
        var dQuantity = OdinObject_1.OdinObject.PARSER(ctx.odinObjectValue());
        var dProperty = dQuantity.tryGet('property');
        if (dProperty != null) {
            result.property = AdlTreeParserUtils_1.parseCodePhraseListSingleItem(dProperty.odinCodePhraseValueList());
        }
        var dItem = dQuantity.tryGet('list');
        if (dItem != null && dItem.odinMapValue() != null) {
            result.list = dItem.odinMapValue().odinMapValueEntry().map(function (entryContext) {
                return _this.parseCQuantityItem(entryContext.odinValue().odinObjectValue());
            });
        }
        var dAssumedValue = dQuantity.tryGet('assumed_value');
        if (dAssumedValue != null) {
            result.assumedValue = this.parseDvQuantity(dAssumedValue.odinObjectValue());
        }
        return result;
    };
    AdlTreeConstraintParser.prototype.parseCQuantityItem = function (ctx) {
        var result = new CQuantityItem_1.CQuantityItem();
        var dContext = OdinObject_1.OdinObject.PARSER(ctx);
        result.units = AdlTreeParserUtils_1.collectString(dContext.getValue('units').openStringList());
        var pMagnitude = dContext.tryGet('magnitude');
        if (pMagnitude != null) {
            result.magnitude = AdlTreePrimitiveConstraintsParser_1.parseNumberInterval(pMagnitude.numberIntervalConstraint());
        }
        var pPrecision = dContext.tryGet('precision');
        if (pPrecision != null) {
            result.precision = AdlTreePrimitiveConstraintsParser_1.parseNumberInterval(pPrecision.numberIntervalConstraint());
        }
        return result;
    };
    AdlTreeConstraintParser.prototype.parseDvQuantity = function (ctx) {
        var result = new DvQuantity_1.DvQuantity();
        var dContext = OdinObject_1.OdinObject.PARSER(ctx);
        result.units = dContext.tryGetString('units');
        var tMagnitude = dContext.tryGetFloat('magnitude');
        if (tMagnitude != null) {
            result.magnitude = tMagnitude;
        }
        result.precision = dContext.tryGetInteger('precision');
        return result;
    };
    AdlTreeConstraintParser.prototype.parseArchetypeReference = function (ctx, path) {
        var result = new CArchetypeRoot_1.CArchetypeRoot();
        result.rmTypeName = AdlTreeParserUtils_1.collectNonNullText(ctx.typeIdentifier());
        result.nodeId = AdlTreeParserUtils_1.collectText(ctx.AT_CODE_VALUE());
        result.rmType = CArchetypeRoot_1.CArchetypeRoot.name;
        result.archetypeRef = AdlTreeParserUtils_1.collectNonNullText(ctx.archetypeId());
        result.occurrences = this.parseOccurrences(ctx.occurrences());
        result.aPath = path + "[" + result.nodeId + "]";
        //this.archetype.paths.push({aPath: result.aPath, type: result.rmTypeName, value: undefined});
        return result;
    };
    AdlTreeConstraintParser.prototype.parseCDvOrdinalConstraint = function (ctx) {
        var result = new CDvOrdinal_1.CDvOrdinal();
        result.rmTypeName = 'DV_ORDINAL';
        result.list = ctx.ordinalItemList().ordinalItem().map(this.parseOrdinalItem);
        if (ctx.number() != null) {
            var num_1 = AdlTreeParserUtils_1.parseInteger(ctx.number());
            var ordinalFound = result.list.find(function (dvOrdinal) { return dvOrdinal.value === num_1; });
            result.assumedValue = Object.assign({}, ordinalFound);
        }
        return result;
    };
    AdlTreeConstraintParser.prototype.parseOrdinalItem = function (ctx) {
        var result = new DvOrdinal_1.DvOrdinal();
        result.value = AdlTreeParserUtils_1.parseInteger(ctx.number());
        var code = AdlTreeParserUtils_1.parseCodePhrase(ctx.odinCodePhraseValue());
        result.symbol = new DvCodedText_1.DvCodedText({ definingCode: code, value: code.codeString });
        return result;
    };
    return AdlTreeConstraintParser;
}());
exports.AdlTreeConstraintParser = AdlTreeConstraintParser;
//# sourceMappingURL=AdlTreeConstraintParser.js.map