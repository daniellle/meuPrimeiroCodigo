"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var ArchetypeTerminologyItem_1 = require("../am/ArchetypeTerminologyItem");
var OperationalTemplate_1 = require("../am/OperationalTemplate");
var AmQuery_1 = require("../query/AmQuery");
var ArchetypeRepositoryOverlay_1 = require("./ArchetypeRepositoryOverlay");
var TypeGuard_1 = require("../rminfo/TypeGuard");
var OperationalTemplateBuilder = /** @class */ (function () {
    function OperationalTemplateBuilder(repository, template) {
        this.presentTerminologies = new Set();
        this.result = new OperationalTemplate_1.OperationalTemplate();
        this.template = _.cloneDeep(template);
        var overlays = tslib_1.__spread(template.overlays);
        overlays.push(template);
        this.repository = new ArchetypeRepositoryOverlay_1.ArchetypeRepositoryOverlay(repository, overlays);
    }
    OperationalTemplateBuilder.BUILD = function (repository, template) {
        return new OperationalTemplateBuilder(repository, template).build();
    };
    OperationalTemplateBuilder.prototype.build = function () {
        var _a = this.template, overlays = _a.overlays, rest = tslib_1.__rest(_a, ["overlays"]);
        Object.assign(this.result, rest);
        this.result.isDifferential = false;
        this.expandTemplate();
        this.result.paths = [];
        this.walkAPath(this.result.definition);
        return this.result;
    };
    OperationalTemplateBuilder.prototype.walkAPath = function (cObject, aPath, archetypeRef) {
        if (aPath === void 0) { aPath = ''; }
        if (archetypeRef === void 0) { archetypeRef = ''; }
        if (TypeGuard_1.isCCOmplexObject(cObject)) {
            if (TypeGuard_1.isCArchetypeRoot(cObject)) {
                archetypeRef = cObject.archetypeRef;
                //preserve archetype path
                aPath = '';
            }
            cObject.aPath = aPath;
            //this.result.pathTerminology.push({path: cObject.aPath, code: archetypeRef});
            this.result.paths.push({
                aPath: cObject.aPath,
                type: cObject.rmTypeName,
                rmType: cObject.rmType,
                archetypeRef: archetypeRef
            });
            var cComplexObject = cObject;
            try {
                for (var _a = tslib_1.__values(cComplexObject.attributes), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var att = _b.value;
                    try {
                        for (var _c = tslib_1.__values(att.children), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var c = _d.value;
                            c.aPath = aPath + "/" + att.rmAttributeName + (c.nodeId != null ? "[" + c.nodeId + "]" : '');
                            this.walkAPath(c, c.aPath, archetypeRef);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        var e_2, _f, e_1, _e;
    };
    OperationalTemplateBuilder.prototype.expandTemplate = function () {
        var a = this.repository.getFlatArchetype(this.result.archetypeId);
        this.presentTerminologies.add(a.archetypeId);
        this.result.terminology = a.terminology;
        var context = [];
        context.push(this.result);
        this.expandCObject(context, this.result.definition);
        context.pop();
    };
    OperationalTemplateBuilder.prototype.expandCObject = function (context, cobj) {
        if (TypeGuard_1.isCArchetypeRoot(cobj)) {
            var car = cobj;
            var a = this.repository.getFlatArchetype(car.archetypeRef);
            var aid = a.archetypeId;
            if (!this.presentTerminologies.has(aid)) {
                var at = Object.assign(new ArchetypeTerminologyItem_1.ArchetypeTerminologyItem(), {
                    code: aid,
                    value: a.terminology
                });
                this.result.componentTerminologies.push(at);
                this.presentTerminologies.add(aid);
            }
            context.push(a);
            (_a = car.attributes).push.apply(_a, tslib_1.__spread(_.cloneDeep(a.definition.attributes)));
        }
        if (TypeGuard_1.isCCOmplexObject(cobj)) {
            this.expandCComplexObject(context, cobj);
        }
        if (TypeGuard_1.isCArchetypeRoot(cobj)) {
            context.pop();
        }
        var _a;
    };
    OperationalTemplateBuilder.prototype.expandCComplexObject = function (context, cobj) {
        var _this = this;
        cobj.attributes = cobj.attributes.map(function (attribute) {
            if (_this.isProhibitedCAttribute(attribute)) {
                return null;
            }
            else {
                _this.expandCAttribute(context, attribute);
                return attribute;
            }
        }).filter(function (attribute) { return attribute; });
    };
    OperationalTemplateBuilder.prototype.isProhibitedCAttribute = function (attribute) {
        return attribute.existence != null
            && attribute.existence.upper != null
            && attribute.existence.upper === 0;
    };
    OperationalTemplateBuilder.prototype.isProhibitedCObject = function (cobj) {
        return cobj.occurrences != null
            && cobj.occurrences.upper != null
            && cobj.occurrences.upper === 0;
    };
    OperationalTemplateBuilder.prototype.expandCAttribute = function (context, attribute) {
        var _this = this;
        attribute.children = attribute.children.map(function (cobj) {
            if (_this.isProhibitedCObject(cobj)) {
                return null;
            }
            else if (TypeGuard_1.isArchetypeSlot(cobj)) {
                var slot = cobj;
                if (slot.isClosed) {
                    return null;
                }
                else {
                    _this.expandCObject(context, cobj);
                    return cobj;
                }
            }
            else if (TypeGuard_1.isArchetypeInternalRef(cobj)) {
                var iar = cobj;
                var target = AmQuery_1.AmQuery.FIND(context[context.length - 1], iar.targetPath);
                var newCObject = _.cloneDeep(target);
                _this.expandCObject(context, newCObject);
                return newCObject;
            }
            else {
                _this.expandCObject(context, cobj);
                return cobj;
            }
        }).filter(function (cobj) { return cobj; });
    };
    return OperationalTemplateBuilder;
}());
exports.OperationalTemplateBuilder = OperationalTemplateBuilder;
//# sourceMappingURL=OperationalTemplateBuilder.js.map